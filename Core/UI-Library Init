local function getGlobalTable()
	return typeof(getfenv().getgenv) == "function" and typeof(getfenv().getgenv()) == "table" and getfenv().getgenv() or _G
end
if getGlobalTable()._FIRELIB then
	task.spawn(function()
		task.wait()
		script.Parent:Destroy()
	end)
	return getGlobalTable()._FIRELIB
end
local writefile, readfile = getfenv().writefile, getfenv().readfile
local configsEnabled = typeof(writefile) == "function" and typeof(readfile) == "function"

local versions
if not pcall(function()
		local str = game:HttpGet("https://raw.githubusercontent.com/InfernusScripts/Fire-Hub/main/Core/Version"):split("\n")
		versions = {
			["FireLibraryVersion"] = str[2],
			["FireHubVersion"] = str[1]
		}
	end) then
	versions = {
		["FireLibraryVersion"] = "5.0",
		["FireHubVersion"] = "4.0.1"
	}
end

local isMobile = game.UserInputService.TouchEnabled and not game.UserInputService.KeyboardEnabled
local uiHolder = getfenv().gethui and getfenv().gethui() or pcall(function() return game.CoreGui:GetFullName() end) and game.CoreGui:FindFirstChild("RobloxGui") or game.Players.LocalPlayer.PlayerGui
script.Parent.Parent = uiHolder

local function playSound(soundName)
	task.spawn(function()
		local sCopy = script.Parent.Sounds.SoundsFolder:FindFirstChild(soundName)
		if not sCopy then return end
		sCopy = sCopy:Clone()
		sCopy.Parent = script.Parent.Sounds
		sCopy.Volume = 0.5
		sCopy.Looped = false
		sCopy.TimePosition = 0
		sCopy:Play()
		task.wait(sCopy.TimeLength)
		sCopy:Destroy()
	end)
end

local function setupSlider(slider, holder, options)
	local val = options.Default
	local prevVal = val
	local customTextDisplay = function(val, max)
		if typeof(options.CustomTextDisplay) == "function" then
			local res = options.CustomTextDisplay(val, max)
			if typeof(res) == "string" or typeof(res) == "number" then
				return tostring(res)
			end
		end
		return val .. " / " .. max
	end
	holder = holder or slider.Parent:IsA("Button") and slider.Parent or slider:FindFirstChildOfClass("TextButton") or slider
	local sliderDrag = holder
	local sliderBar = slider.SliderOuter.Bar.Fill
	local dragging = false

	sliderDrag.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then 
			dragging = true 
		end 
	end)
	sliderDrag.InputEnded:Connect(function(input) 
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then 
			dragging = false 
		end 
	end)

	local function round(Number, Factor)
		local Result = math.floor(Number/Factor + (math.sign(Number) * 0.5)) * Factor
		if Result < 0 then Result = Result + Factor end
		return Result
	end

	local newVal
	local function set(num)
		newVal = math.round((math.clamp(round(num, options.Step), options.Min, options.Max))*1000)/1000
		if newVal then
			sliderBar:TweenSize(UDim2.fromScale((newVal - options.Min) / (options.Max - options.Min), 1), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
			val = newVal
			sliderBar.Parent.Progress.Text = customTextDisplay(val, options.Max)
			if newVal ~= prevVal then
				coroutine.wrap(playSound)("MouseHover")
				coroutine.wrap(options.Callback)(newVal)
				prevVal = newVal
				newVal = nil
			end
		end
	end

	game.UserInputService.InputChanged:Connect(function(input)
		if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or Enum.UserInputType.Touch) then 
			local sizeScale = math.clamp((input.Position.X - sliderBar.Parent.AbsolutePosition.X) / sliderBar.Parent.AbsoluteSize.X, 0, 1)
			set(options.Min + ((options.Max - options.Min) * sizeScale)) 
		end
	end)

	set(val)

	return set
end

local delta, dragInput
local function update(input, gui, dragStart, startPos)
	delta = input.Position - dragStart
	gui:TweenPosition(UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y), nil, nil, 0.3, true)
	delta = nil	
end

local function makeDraggable(gui)
	local dragging, dragStart, startPos, delta

	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position

			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)

	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)

	game.UserInputService.InputChanged:Connect(function(input)
		if input == dragInput and dragging then
			update(input, gui, dragStart, startPos)
		end
	end)
end

local function getOptions(options) -- cuz i was lazy to always insert the same line of code
	-- also idk how properly call that function
	return typeof(options) == "table" and options or {}
end
local function getCallback(options)
	return typeof(options.Function) == "function" and options.Function or typeof(options.Callback) == "function" and options.Callback or function() end
end
local function getText(options)
	return typeof(options.Title) == "string" and options.Title or typeof(options.Caption) == "string" and options.Caption or typeof(options.Name) == "string" and options.Name or typeof(options.Text) == "string" and options.Text or typeof(options.Description) == "string" and options.Description or typeof(options.Content) == "string" and options.Content
end

local lib; lib = {
	SetThemeColor = setmetatable({}, {
		__call = function(self, themeId, themeCol)
			themeId = tostring(themeId)
		end,
		__newindex = function(self, themeId, themeCol)
			themeId = tostring(themeId)

		end,
		__index = function(self, themeId)
			themeId = tostring(themeId)
		end,
	}),
	Notifications = {
		_AnimateNotification = {
			In = function(notification)
				if not notification or not notification.Parent then return end
				playSound("Notification")
				local size = notification.Size
				notification.Size = UDim2.fromScale()
				notification.Visible = true
				notification:TweenSize(size, nil, nil, 0.3, true)
				notification.NotificationOrange.Position = UDim2.new(-1, -1, 0, 0)
				notification.NotificationOrange.NotificationMain.Position = UDim2.new(-1, 0, 0, 2)
				task.wait(0.32)
				if not notification or not notification.Parent then return end
				notification.NotificationOrange:TweenPosition(UDim2.fromScale(0,0), nil, nil, 0.3, true)
				notification.NotificationOrange.NotificationMain:TweenPosition(UDim2.fromOffset(0, 2), nil, nil, 0.45, true)
			end,
			Out = function(notification)
				if not notification or not notification.Parent then return end
				notification.NotificationOrange.NotificationMain:TweenPosition(UDim2.new(-1, 0, 0, 2), nil, nil, 0.45, true)
				notification.NotificationOrange:TweenPosition(UDim2.new(-1, -1, 0, 0), nil, nil, 0.3, true)
				task.wait(0.32)
				if not notification or not notification.Parent then return end
				notification:TweenSize(UDim2.fromScale(0, 0), nil, nil, 0.3, true)
				task.wait(0.31)
				if not notification or not notification.Parent then return end
				notification:Destroy()
			end
		},
		Notification = function(self, options)
			task.spawn(function()
				local notification = script.Parent.Notification.NotificationHolder:Clone()
				notification.Parent = script.Parent.Notification
				notification.Name = ""
				notification.NotificationOrange.NotificationMain.Bar.Fill.Size = UDim2.fromScale(1,1)
				notification.NotificationOrange.NotificationMain.Bar.Fill.Position = UDim2.fromScale(0,0)
				notification.NotificationOrange.NotificationMain.Title.Text = typeof(options.Title) == "string" and options.Title or typeof(options.Name) == "string" and options.Name or "Notification"
				local text = typeof(options.Text) == "string" and options.Text or typeof(options.Description) == "string" and options.Description or typeof(options.Content) == "string" and options.Content or ""
				notification.NotificationOrange.NotificationMain.Lines["1"].Text = text
				coroutine.wrap(self._AnimateNotification.In)(notification)
				local time = tonumber(options.Time) or tonumber(options.Delay) or tonumber(options.Length) or 5
				notification.NotificationOrange.NotificationMain.Bar.Fill:TweenSizeAndPosition(UDim2.fromScale(0, 1), UDim2.fromScale(1, 0), Enum.EasingDirection.InOut, Enum.EasingStyle.Linear, time, true)
				task.wait(time)
				coroutine.wrap(self._AnimateNotification.Out)(notification)
			end)
		end,
		ChooseNotification = function(self, options)
			task.spawn(function()
				local notification = script.Parent.Notification.ChooseNotificationHolder:Clone()
				notification.Parent = script.Parent.Notification
				notification.Name = ""
				notification.NotificationOrange.NotificationMain.Bar.Fill.Size = UDim2.fromScale(1,1)
				notification.NotificationOrange.NotificationMain.Bar.Fill.Position = UDim2.fromScale(0,0)
				notification.NotificationOrange.NotificationMain.Title.Text = typeof(options.Title) == "string" and options.Title or typeof(options.Name) == "string" and options.Name or "Notification"
				local text = typeof(options.Text) == "string" and options.Text or typeof(options.Description) == "string" and options.Description or typeof(options.Content) == "string" and options.Content or ""
				notification.NotificationOrange.NotificationMain.Lines["1"].Text = text
				local done = false
				notification.NotificationOrange.NotificationMain.Yes.MouseButton1Click:Connect(function()
					if done then return end
					coroutine.wrap(self._AnimateNotification.Out)(notification)
					done = true
					getCallback(options)(true)
				end)
				notification.NotificationOrange.NotificationMain.No.MouseButton1Click:Connect(function()
					if done then return end
					coroutine.wrap(self._AnimateNotification.Out)(notification)
					done = true
					getCallback(options)(false)
				end)
				coroutine.wrap(self._AnimateNotification.In)(notification)
				local time = tonumber(options.Time) or tonumber(options.Delay) or tonumber(options.Length) or 5
				notification.NotificationOrange.NotificationMain.Bar.Fill:TweenSizeAndPosition(UDim2.fromScale(0, 1), UDim2.fromScale(1, 0), Enum.EasingDirection.InOut, Enum.EasingStyle.Linear, time, true)
				task.wait(time)
				coroutine.wrap(self._AnimateNotification.Out)(notification)
			end)
		end
	},
	Versions = versions,
	MakeWindow = function(self, options)
		local configStructure = {}
		local configEvent = Instance.new("BindableEvent")
		local counter = {}
		local function count(name, layer)
			counter[layer] = counter[layer] or {}
			counter[layer][name] = (tonumber(counter[layer][name]) or 0) + 1
			return name..counter[layer][name]
		end
		options = getOptions(options)
		for i=1, 5 do
			game["Run Service"].RenderStepped:Wait()
		end
		local session = {}
		local cons = {}
		local window = script.Parent.Holder.Window:Clone()
		window.Parent = script.Parent.Holder
		local fadeTime = 1
		local size = window.Size
		window.Name = ""
		window.HolderFrame.Title.Text = getText(options) or "Fire Library | "..versions.FireLibraryVersion
		window.Visible = true
		window.Position = UDim2.fromScale(0.5, 0.5)
		window.HolderFrame.StarterFade.Visible = true
		window.Size = UDim2.fromScale(0,0)
		local maximize = script.Parent.Holder.MobileMaximize:Clone()
		maximize.Parent = script.Parent.Holder
		maximize.Name = ""
		maximize.Visible = false
		makeDraggable(maximize.DragButton)
		makeDraggable(window)

		local cd = false
		local windowFuncs = {
			Close = function(self)
				task.spawn(function()
					while cd and task.wait() do end
					self:Hide()
					task.wait(fadeTime + 0.01)
					window:Destroy()
				end)
			end,
			Show = function(self)
				if cd then return false end
				task.spawn(function()
					-- for some reason window:TweenSize does not work :|
					cd = true
					maximize.Visible = false
					window.Visible = true
					game.TweenService:Create(window, TweenInfo.new(fadeTime / 2.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size = size}):Play()
					game.TweenService:Create(window.HolderFrame.StarterFade, TweenInfo.new(fadeTime, Enum.EasingStyle.Exponential, Enum.EasingDirection.In), {BackgroundTransparency = 1}):Play()
					task.wait(fadeTime + 0.01)
					cd = false
					window.HolderFrame.StarterFade.ZIndex -= 1000
					window.HolderFrame.StarterFade.Visible = false
				end)
				return true
			end,
			Toggle = function(self, state)
				if state == nil then
					state = window.Visible
				else
					state = not state
				end
				if state then
					return self:Hide()
				else
					return self:Show()
				end
			end,
			Hide = function(self)
				if cd then return false end
				task.spawn(function()
					cd = true
					maximize.Visible = isMobile
					window.HolderFrame.StarterFade.Visible = true
					window.HolderFrame.StarterFade.ZIndex += 1000
					game.TweenService:Create(window, TweenInfo.new(fadeTime, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {Size = UDim2.fromScale(0,0)}):Play()
					game.TweenService:Create(window.HolderFrame.StarterFade, TweenInfo.new(fadeTime / 2.5, Enum.EasingStyle.Exponential, Enum.EasingDirection.In), {BackgroundTransparency = 0}):Play()
					task.wait(fadeTime + 0.01)
					cd = false
					window.Visible = false
				end)
				return true
			end,
			AddPage = function(self, options)
				options = getOptions(options)
				local text = getText(options) or "Page"
				local counterTextPage = count(text, 1)
				configStructure[counterTextPage] = {}
				local struct = configStructure[counterTextPage]
				local pageButton = window.HolderFrame.PageButtons.PageButton:Clone()
				pageButton.Parent = window.HolderFrame.PageButtons
				pageButton.Visible = true
				pageButton.Name = ""
				pageButton:FindFirstChild("Text").Text = text
				cons[#cons+1] = pageButton.Trigger.MouseEnter:Connect(function()
					playSound("MouseHover")
				end)
				pageButton.Size = UDim2.fromScale((#pageButton:FindFirstChild("Text").Text / 65) + 0.05, 1)
				local page = window.HolderFrame.PageDisplay.Page:Clone()
				page.Parent = window.HolderFrame.PageDisplay
				page.Name = ""
				cons[#cons+1] = pageButton.Trigger.MouseButton1Click:Connect(function()
					playSound("Click")
					if pageButton.Selection.Visible then
						page.Visible = false
						pageButton.Selection.Visible = false
					else
						for i,v in page.Parent:GetChildren() do
							if v and v:IsA(page.ClassName) then
								v.Visible = false
							end
						end
						page.Visible = true
						for i,v in pageButton.Parent:GetChildren() do
							if v and v:IsA(pageButton.ClassName) then
								v.Selection.Visible = false
							end
						end
						pageButton.Selection.Visible = true
					end
				end)

				local pageFuncs = {
					AddSlider = function(self, options)
						options = getOptions(options)
						options.Min = tonumber(options.Min or options.Minimum) or 0
						options.Max = tonumber(options.Max or options.Maximum) or 100
						options.Callback = getCallback(options)
						local text = getText(options) or "Slider"
						local counterText = count(text, 2)
						if options.Min > options.Max then
							local max, min = options.Max, options.Min
							options.Min = max
							options.Max = min
						elseif options.Min == options.Max then
							local cb = options.Callback
							options.Callback = function()
								cb(options.Min)
							end
							return self:AddButton(options)
						end
						local funcs = {Options = options}
						options.Step = tonumber(options.Step) or tonumber(options.Per) or (options.Max - options.Min) / 25
						options.Default = tonumber(options.Default) or tonumber(options.Base) or options.Min
						local cb = options.Callback

						--

						local slider = page.Slider:Clone()
						slider.Parent = page
						slider.Name = ""
						slider.Visible = true
						slider:FindFirstChild("Text").Text = text
						funcs.Object = slider

						local set = setupSlider(slider, nil, options)
						set(options.Default)
						options.Callback = function(newVal)
							if funcs.Value == newVal then return end
							funcs.Value = newVal
							set(newVal)
							struct[counterText] = newVal
							return cb(newVal)
						end
						options.Set = set

						--

						function funcs:Set(value)
							if not self or not self.Object then return end
							self.Options.Set(tonumber(value) or self.Value)
						end
						function funcs:SetCustomTextDisplay(func)
							if not self or not self.Object then return end
							self.Options.CustomTextDisplay = func
						end
						function funcs:SetStep(val)
							if not self or not self.Object then return end
							self.Options.Step = tonumber(val) or self.Options.Step
						end
						function funcs:SetMinimum(val)
							if not self or not self.Object then return end
							self.Options.Min = tonumber(val) or self.Options.Min
						end
						function funcs:SetMaximum(val)
							if not self or not self.Object then return end
							self.Options.Max = tonumber(val) or self.Options.Max
						end
						function funcs:SetCallback(cb)
							if not self or not self.Object then return end
							self.Options.Callback = function(newVal)
								funcs.Value = newVal
								return cb(newVal)
							end
						end
						function funcs:SetText(txt)
							if not self or not self.Object then return end
							self.Object:FindFirstChild("Text").Text = tostring(txt)
						end
						function funcs:Destroy()
							if not self or not self.Object then return end
							self.Object:Destroy()
						end
						function funcs:Hide()
							if not self or not self.Object then return end
							self.Object.Visible = false
						end
						function funcs:Show()
							if not self or not self.Object then return end
							self.Object.Visible = true
						end
						function funcs:Visible(bool)
							if not self or not self.Object then return end
							self.Object.Visible = not not bool
						end
						funcs.SetMax = funcs.SetMaximum
						funcs.SetMin = funcs.SetMinimum

						configEvent.Event:Connect(function(config)
							if options.IgnoreConfig or options.IgnoreConfigs then return end
							local val = config[counterTextPage]
							if val then
								val = val[counterText]
							end
							if not val then return end
							funcs:Set(val)
						end)

						return funcs
					end,
					AddSeparator = function(self)
						local sep = page.Separator:Clone()
						sep.Parent = page
						sep.Visible = true
						sep.Name = ""

						local funcs = {}
						funcs.Object = sep
						function funcs:Destroy()
							if not self or not self.Object then return end
							self.Object:Destroy()
						end
						function funcs:Hide()
							if not self or not self.Object then return end
							self.Object.Visible = false
						end
						function funcs:Show()
							if not self or not self.Object then return end
							self.Object.Visible = true
						end
						function funcs:Visible(bool)
							if not self or not self.Object then return end
							self.Object.Visible = not not bool
						end

						return sep
					end,
					AddButton = function(self, options)
						options = getOptions(options)

						local button = page.Button:Clone()
						button.Parent = page
						button.Visible = true
						button.Name = ""
						button:FindFirstChild("Text").Text = getText(options) or "Button"
						cons[#cons+1] = button.Trigger.MouseEnter:Connect(function()
							playSound("MouseHover")
						end)
						cons[#cons+1] = button.Trigger.MouseButton1Click:Connect(function()
							playSound("Click")
							getCallback(options)()
						end)
						local funcs = {}
						funcs.Object = button

						function funcs:Destroy()
							if not self or not self.Object then return end
							self.Object:Destroy()
						end
						function funcs:Hide()
							if not self or not self.Object then return end
							self.Object.Visible = false
						end
						function funcs:Show()
							if not self or not self.Object then return end
							self.Object.Visible = true
						end
						function funcs:Visible(bool)
							if not self or not self.Object then return end
							self.Object.Visible = not not bool
						end
						function funcs:SetCallback(cb)
							if not self or not self.Object then return end
							self.Options.Callback = function(newVal)
								funcs.Value = newVal
								return cb(newVal)
							end
						end
						function funcs:SetText(txt)
							if not self or not self.Object then return end
							self.Object:FindFirstChild("Text").Text = tostring(txt)
						end

						return funcs
					end,
					AddToggle = function(self, options)
						options = getOptions(options)

						local state = typeof(options.Default) == "boolean" and options.Default or typeof(options.Base) == "boolean" and options.Base or false
						local toggle = page.Toggle:Clone()
						toggle.Parent = page
						toggle.Visible = true
						toggle.Name = ""
						local text = getText(options) or "Toggle"
						local counterText = count(text, 2)
						toggle:FindFirstChild("Text").Text = text
						cons[#cons+1] = toggle.Trigger.MouseEnter:Connect(function()
							playSound("MouseHover")
						end)
						local funcs = {Options = options}
						local cb = function(bool)
							funcs.Value = bool
							toggle.ToggleOuter.Frame.ImageLabel.Visible = bool
							struct[counterText] = bool
							getCallback(options)(bool)
						end
						cb(state)
						options.CB = cb
						toggle.ToggleOuter.Frame.ImageLabel.Visible = state
						cons[#cons+1] = toggle.Trigger.MouseButton1Click:Connect(function()
							playSound("Click")
							state = not state
							cb(state)
						end)

						funcs.Object = toggle

						function funcs:Destroy()
							if not self or not self.Object then return end
							self.Object:Destroy()
						end
						function funcs:Set(val)
							if not self or not self.Object then return end
							self.Object.ToggleOuter.Frame.ImageLabel.Visible = state
							self.Options.CB(not not val)
						end
						function funcs:Hide()
							if not self or not self.Object then return end
							self.Object.Visible = false
						end
						function funcs:Show()
							if not self or not self.Object then return end
							self.Object.Visible = true
						end
						function funcs:Visible(bool)
							if not self or not self.Object then return end
							self.Object.Visible = not not bool
						end
						function funcs:SetCallback(cb)
							if not self or not self.Object then return end
							self.Options.Callback = function(newVal)
								funcs.Value = newVal
								return cb(newVal)
							end
						end
						function funcs:SetText(txt)
							if not self or not self.Object then return end
							self.Object:FindFirstChild("Text").Text = tostring(txt)
						end

						configEvent.Event:Connect(function(config)
							if options.IgnoreConfig or options.IgnoreConfigs then return end
							local val = config[counterTextPage]
							if val then
								val = val[counterText]
							end
							if not val then return end
							funcs:Set(val)
						end)

						return funcs
					end,
					AddLabel = function(self, options)
						options = getOptions(options)

						local label = page.Label:Clone()
						label.Parent = page
						label.Visible = true
						label.Name = ""
						label:FindFirstChild("Text").Text = getText(options) or "Label"

						local funcs = {}
						funcs.Object = label

						function funcs:Destroy()
							if not self or not self.Object then return end
							self.Object:Destroy()
						end
						function funcs:Hide()
							if not self or not self.Object then return end
							self.Object.Visible = false
						end
						function funcs:Show()
							if not self or not self.Object then return end
							self.Object.Visible = true
						end
						function funcs:Visible(bool)
							if not self or not self.Object then return end
							self.Object.Visible = not not bool
						end
						function funcs:SetText(txt)
							if not self or not self.Object then return end
							self.Object:FindFirstChild("Text").Text = tostring(txt)
						end

						return funcs
					end,
					AddTextBox = function(self, options)
						options = getOptions(options)

						local tb = page.TextBox:Clone()
						tb.Parent = page
						tb.Visible = true
						tb.Name = ""
						local text = getText(options) or "Text Box"
						local counterText = count(text, 2)
						tb:FindFirstChild("Text").Text = text
						tb.TextBoxOuter.TextBox.PlaceholderText = typeof(options.Placeholder) == "string" and options.Placeholder or typeof(options.PlaceholderText) == "string" and options.PlaceholderText or ""
						tb.TextBoxOuter.TextBox.Text = typeof(options.Default) == "string" and options.Default or typeof(options.Base) == "string" and options.Base or ""
						cons[#cons+1] = tb.Trigger.MouseButton1Click:Connect(function()
							playSound("MouseHover")
							tb.TextBoxOuter.TextBox:CaptureFocus()
						end)
						local funcs = {Value = tb.TextBoxOuter.TextBox.Text}
						local function cb(txt)
							funcs.Value = txt
							tb.TextBoxOuter.TextBox.Text = txt
							struct[counterText] = txt
							getCallback(options)(txt)
						end
						options.CB = cb
						cons[#cons+1] = tb.TextBoxOuter.TextBox.FocusLost:Connect(function(enter)
							if (options.Enter or options.NeedEnter or options.NeedsEnter) and enter or not (options.Enter or options.NeedEnter or options.NeedsEnter) then
								playSound("Click")
								cb(tb.TextBoxOuter.TextBox.Text)
							end
						end)

						funcs.Object = tb
						funcs.Options = options

						function funcs:Destroy()
							if not self or not self.Object then return end
							self.Object:Destroy()
						end
						function funcs:Set(txt)
							if not self or not self.Object then return end
							self.Object.TextBoxOuter.TextBox.Text = tostring(txt)
							getCallback(self.Options)(tostring(txt))
						end
						function funcs:SetPlaceholder(txt)
							if not self or not self.Object then return end
							self.Object.TextBoxOuter.TextBox.PlaceholderText = tostring(txt)
						end
						function funcs:Hide()
							if not self or not self.Object then return end
							self.Object.Visible = false
						end
						function funcs:Show()
							if not self or not self.Object then return end
							self.Object.Visible = true
						end
						function funcs:Visible(bool)
							if not self or not self.Object then return end
							self.Object.Visible = not not bool
						end
						function funcs:SetCallback(cb)
							if not self or not self.Object then return end
							self.Options.Callback = function(newVal)
								funcs.Value = newVal
								return cb(newVal)
							end
						end
						function funcs:SetText(txt)
							if not self or not self.Object then return end
							self.Object:FindFirstChild("Text").Text = tostring(txt)
						end
						funcs.SetPlaceholderText = funcs.SetPlaceholder

						configEvent.Event:Connect(function(config)
							if options.IgnoreConfig or options.IgnoreConfigs then return end
							local val = config[counterTextPage]
							if val then
								val = val[counterText]
							end
							if not val then return end
							funcs:Set(val)
						end)

						return funcs
					end,
					AddInput = function(self, options)
						options = getOptions(options)
						options.Default = typeof(options.Default) == "string" and options.Default or typeof(options.Base) == "string" and options.Base or "LeftAlt"

						local blockedCodes = {
							Enum.KeyCode.Unknown,
							Enum.KeyCode.Power,
							Enum.KeyCode.Left,
							Enum.KeyCode.Right,
							Enum.KeyCode.Up,
							Enum.KeyCode.Down,
							Enum.KeyCode.F11,
							Enum.KeyCode.F9,
							Enum.KeyCode.CapsLock,
							Enum.KeyCode.ScrollLock,
							Enum.KeyCode.NumLock
						}
						local funcs = {}
						local text = getText(options) or "Input"
						local counterText = count(text, 2)
						local input = page.Input:Clone()
						local function cb(inpt)
							if tonumber(inpt) then
								inpt = Enum.KeyCode:FromValue(inpt)
							end
							funcs.Value = inpt
							input.InputOuter.Frame.Input.Text = inpt.Name
							struct[counterText] = inpt.Value
							getCallback(options)(inpt)
						end
						options.CB = cb
						local focused = false
						local con
						input.Parent = page
						input.Visible = not isMobile
						input.Name = ""
						input:FindFirstChild("Text").Text = text
						local inpt = Enum.KeyCode:FromName(options.Default) or Enum.KeyCode:FromValue(options.Default)
						input.InputOuter.Frame.Input.Text = inpt.Name
						cons[#cons+1] = input.Trigger.MouseButton1Click:Connect(function()
							playSound("Click")
							focused = not focused
							input.InputOuter.Frame.Input.Text = "..."
							if focused then
								con = game.UserInputService.InputBegan:Connect(function(s, chat)
									if chat or table.find(blockedCodes, s.KeyCode) then return end
									focused = false
									con:Disconnect()
									con = nil
									inpt = s.KeyCode
									cb(inpt)
								end)
							else
								input.InputOuter.Frame.Input.Text = inpt.Name
								if con then
									con:Disconnect()
									con = nil
								end
							end
						end)
						cons[#cons+1] = input.Trigger.MouseEnter:Connect(function()
							playSound("MouseHover")
						end)

						funcs.Object = input

						function funcs:Destroy()
							if not self or not self.Object then return end
							self.Object:Destroy()
						end
						function funcs:Hide()
							if not self or not self.Object then return end
							self.Object.Visible = false
						end
						function funcs:Set(input)
							if not self or not self.Object or (typeof(input) ~= "EnumItem" or input.EnumType ~= Enum.KeyCode or not tonumber(input)) then return end
							if tonumber(input) then
								input = Enum.KeyCode:FromValue(input)
							end
							if not input then return end
							self.Object.InputOuter.Frame.Input.Text = input.Name
							self.Options.CB(input)
						end
						function funcs:Show()
							if not self or not self.Object then return end
							self.Object.Visible = true
						end
						function funcs:Visible(bool)
							if not self or not self.Object then return end
							self.Object.Visible = not not bool
						end
						function funcs:SetCallback(cb)
							if not self or not self.Object then return end
							self.Options.Callback = function(newVal)
								funcs.Value = newVal
								return cb(newVal)
							end
						end
						function funcs:SetText(txt)
							if not self or not self.Object then return end
							self.Object:FindFirstChild("Text").Text = tostring(txt)
						end

						configEvent.Event:Connect(function(config)
							if options.IgnoreConfig or options.IgnoreConfigs then return end
							local val = config[counterTextPage]
							if val then
								val = val[counterText]
							end
							if not val then return end
							funcs:Set(val)
						end)

						return funcs
					end,
					AddDropdown = function(self, options)
						options = getOptions()
						options.Default = tonumber(options.Default) or tonumber(options.Base) or 1
						local dd = page.Dropdown:Clone()
						dd.Parent = page
						dd.Visible = true
						dd.Name = ""
						local text = getText(options) or "Dropdown"
						local counterText = count(text, 2)
						dd:FindFirstChild("Text").Text = text
						local selected = options.Default
						dd.DropdownOuter.Default.Text = selected
						local open = false
						local function toggle(state)
							state = state == nil and not open or not not state
							open = state
							dd.Size = state and UDim2.fromScale(1, 0.4) or UDim2.fromScale(1, 0.1)
							dd.DropdownOuter.Default.Visible = not state
							dd.DropdownOuter.ContentHolder.Values.Visible = state
							dd:FindFirstChild("Text").Size = state and UDim2.fromScale(0.9, 0.1) or UDim2.fromScale(0.9, 0.4)
							dd:FindFirstChild("Text").Position = state and UDim2.fromScale(0.9, 0.013) or UDim2.fromScale(0.9, 0.05)
							dd.DropdownOuter.Size = state and UDim2.new(0.9, -2, 0.8, 0) or UDim2.new(0.9, -2, 0.4, 0)
							dd.DropdownOuter.Position = state and UDim2.new(0.05, 1, 0.125, 0) or UDim2.new(0.05, 1, 0.5)
						end
						local function cb(newVal)
							selected = newVal
							dd.DropdownOuter.Default.Text = newVal
							struct[counterText] = newVal
							for i,v in dd.DropdownOuter.ContentHolder.Values:GetChildren() do
								if v.Text == newVal then
									v.TextColor = Color3.fromRGB(255, 125, 0)
								else
									v.TextColor = Color3.new(1,1,1)
								end
							end
							getCallback(options)(newVal)
						end
						toggle(false)
						dd.Trigger.MouseButton1Click:Connect(toggle)
						for i,v in pairs(typeof(options.Selections) == "table" and options.Selections or typeof(options.Rows) == "table" and options.Rows or {}) do
							if typeof(v) == "string" then
								local row = dd.DropdownOuter.ContentHolder.Values.ListButton:Clone()
								row.Parent = dd.DropdownOuter.ContentHolder.Values
								row.Name = ""
								row.Visible = true
								if v == selected then
									row.TextColor3 = Color3.fromRGB(255, 125, 0)
								end
								row.MouseButton1Click:Connect(function()
									toggle(false)
									coroutine.wrap(cb)(v)
									for i,v in row.Parent:GetChildren() do
										v.TextColor3 = Color3.new(1,1,1)
									end
									row.TextColor3 = Color3.fromRGB(255, 125, 0)
								end)
							end
						end

						local funcs = {}
						funcs.Object = dd
						funcs.TGL = toggle
						funcs.CB = cb

						function funcs:Destroy()
							if not self or not self.Object then return end
							self.Object:Destroy()
						end
						function funcs:Hide()
							if not self or not self.Object then return end
							self.Object.Visible = false
						end
						function funcs:Show()
							if not self or not self.Object then return end
							self.Object.Visible = true
						end
						function funcs:Visible(bool)
							if not self or not self.Object then return end
							self.Object.Visible = not not bool
						end
						function funcs:SetText(txt)
							if not self or not self.Object then return end
							self.Object:FindFirstChild("Text").Text = tostring(txt)
						end
						function funcs:Set(txt)
							if not self or not self.Object then return end
							self.CB(txt)
						end
						function funcs:Toggle(state)
							if not self or not self.Object then return end
							self.TGL(state)
						end

						configEvent.Event:Connect(function(config)
							if options.IgnoreConfig or options.IgnoreConfigs then return end
							local val = config[counterTextPage]
							if val then
								val = val[counterText]
							end
							if not val then return end
							funcs:Set(val)
						end)

						return funcs
					end,
					AddColorPicker = function(self, options)
						options = getOptions(options)
						options.Default = typeof(options.Default) == "Color3" and options.Default or typeof(options.Base) == "Color3" and options.Base or Color3.fromRGB(255, 255, 255)

						local cp = page.ColorPicker:Clone()
						cp.Parent = page
						cp.Visible = true
						cp.Name = ""
						local text = getText(options) or "Color Picker"
						local counterText = count(text, 2)
						cp:FindFirstChild("Text").Text = text

						local col = options.Default
						cp:FindFirstChild("Text").Color.BackgroundColor3 = col
						cp.RGB.RHolder.SliderOuter.Bar.Fill.BackgroundColor3 = Color3.new(col.R, 0, 0)
						cp.RGB.GHolder.SliderOuter.Bar.Fill.BackgroundColor3 = Color3.new(0, col.G, 0)
						cp.RGB.BHolder.SliderOuter.Bar.Fill.BackgroundColor3 = Color3.new(0, 0, col.B)
						local funcs = {Value = col}
						local Rs, Gs, Bs
						local function cb(col)
							funcs.Value = col
							Rs(math.round(col.R * 255))
							Gs(math.round(col.G * 255))
							Bs(math.round(col.B * 255))
							struct[counterText] = {col.R * 255, col.G * 255, col.B * 255}
							getCallback(options)(col)
						end
						options.CB = cb
						Rs, Gs, Bs = 
							setupSlider(cp.RGB.RHolder, nil, {Min = 0, Max = 255, Step = 1, Default = math.round(col.R * 255), Callback = function(v)
								if v == col.R then return end
								col = Color3.new(v/255, col.G, col.B)
								cp:FindFirstChild("Text").Color.BackgroundColor3 = col
								cp.RGB.RHolder.SliderOuter.Bar.Fill.BackgroundColor3 = Color3.fromRGB(v, 0, 0)
								cb(col)
							end}),
						setupSlider(cp.RGB.GHolder, nil, {Min = 0, Max = 255, Step = 1, Default = math.round(col.G * 255), Callback = function(v)
							if v == col.G then return end
							col = Color3.new(col.R, v/255, col.B)
							cp:FindFirstChild("Text").Color.BackgroundColor3 = col
							cp.RGB.GHolder.SliderOuter.Bar.Fill.BackgroundColor3 = Color3.fromRGB(0, v, 0)
							cb(col)
						end}),
						setupSlider(cp.RGB.BHolder, nil, {Min = 0, Max = 255, Step = 1, Default = math.round(col.B * 255), Callback = function(v)
							if v == col.B then return end
							col = Color3.new(col.R, col.G, v/255)
							cp:FindFirstChild("Text").Color.BackgroundColor3 = col
							cp.RGB.BHolder.SliderOuter.Bar.Fill.BackgroundColor3 = Color3.fromRGB(0, 0, v)
							cb(col)
						end})

						funcs.Object = cp
						funcs.Options = options

						function funcs:Destroy()
							if not self or not self.Object then return end
							self.Object:Destroy()
						end
						function funcs:Set(obj)
							if not self or not self.Object or typeof(obj) ~= "Color3" then return end
							self.Options.CB(obj)
						end
						function funcs:Hide()
							if not self or not self.Object then return end
							self.Object.Visible = false
						end
						function funcs:Show()
							if not self or not self.Object then return end
							self.Object.Visible = true
						end
						function funcs:Visible(bool)
							if not self or not self.Object then return end
							self.Object.Visible = not not bool
						end
						function funcs:SetCallback(cb)
							if not self or not self.Object then return end
							self.Options.Callback = function(newVal)
								funcs.Value = newVal
								return cb(newVal)
							end
						end
						function funcs:SetText(txt)
							if not self or not self.Object then return end
							self.Object:FindFirstChild("Text").Text = tostring(txt)
						end

						configEvent.Event:Connect(function(config)
							if options.IgnoreConfig or options.IgnoreConfigs then return end
							local val = config[counterTextPage]
							if val then
								val = val[counterText]
							end
							if not val then return end
							funcs:Set(val)
						end)

						return funcs
					end,
				}
				pageFuncs.AddSwitch = pageFuncs.AddToggle
				for i,v in pageFuncs do
					if i:sub(1,3) == "Add" then
						pageFuncs[i:gsub("Add", "Create")] = v
						pageFuncs[i:gsub("Add", "")] = v
					end
				end

				return pageFuncs
			end,
		}
		windowFuncs.Shutdown = windowFuncs.Close
		windowFuncs.Minimize = windowFuncs.Hide
		windowFuncs.Maximize = windowFuncs.Show
		windowFuncs:Show()
		windowFuncs.InitFireHub = function(self)
			local page = self:AddPage({Title = "Info"})
			page:AddLabel({Text = "Fire-Hub version: "..versions.FireHubVersion})
			page:AddLabel({Text = "Fire-Lib version: "..versions.FireLibraryVersion})
			local isExec = true
			local exec, ver
			if typeof(getfenv().identifyexecutor) == "function" then
				exec, ver = getfenv().identifyexecutor()
				if typeof(exec) == "string" and typeof(ver) ~= "string" then
					ver = "Unknown"
				elseif typeof(exec) ~= "string" then
					isExec = false
					ver = getfenv().version()
					exec = (game["Run Service"]:IsStudio() and "Studio" or "RobloxApp") .. (game["Run Service"]:IsClient() and "Client" or "Server")
				end
			else
				ver = getfenv().version()
				exec = (game["Run Service"]:IsStudio() and "Studio" or "RobloxApp") .. (game["Run Service"]:IsClient() and "Client" or "Server")
				isExec = false
			end
			page:AddLabel({Text = "Executor: "..exec..", Version: "..ver})
			if isExec then
				page:AddSeparator()
				page:AddTextBox({Enter = false, Text = "Spoof Executor", Placeholder = "Example: [ExecName, Version]", Default = exec..", "..ver, Callback = function(txt)
					local splits = txt:split(", ")
					local execu, vers = splits[1], splits[2]
					local getgenv = getfenv().getgenv or getfenv
					getgenv().identifyexecutor = function()
						return execu, vers
					end
					getgenv().getexecutor = getgenv().identifyexecutor
					getgenv().getexecutorname = getgenv().identifyexecutor
					getgenv().executor = execu
				end, IgnoreConfigs = true})
			end
			local qotp = getfenv().queue_on_teleport or getfenv().queueonteleport
			if qotp then
				local keep = false
				page:AddToggle({Text = "Keep Fire~Hub on teleport", Callback = function(b)
					keep = b
					lib.Notifications:Notification({Title = "Warning", Text = "If you will close Fire~Hub,\nTHAT SETTING WONT APPLY!\n\nYou need to keep Fire~Hub opened!"})
				end, IgnoreConfigs = true})
				cons[#cons+1] = game.Players.LocalPlayer.OnTeleport:Connect(function()
					if keep then
						qotp([[loadstring(game:HttpGet("https://raw.githubusercontent.com/InfernusScripts/Fire-Hub/main/Loader"))()]])
					end
				end)
			end
		end

		local page = windowFuncs:AddPage({Title = "Main"})
		local toggleKey = Enum.KeyCode.LeftAlt
		page:AddButton({Text = "Hide UI", Callback = function()
			if windowFuncs:Minimize() then
				lib.Notifications:Notification({Title = "UI Hidden", Text = "Press "..toggleKey.Name.." to show the UI"})
			end
		end})
		page:AddInput({Text = "Toggle UI Key", Default = toggleKey.Name, Callback = function(kk)
			toggleKey = kk
		end, IgnoreConfigs = true})
		cons[#cons+1] = game.UserInputService.InputBegan:Connect(function(input)
			if game.UserInputService:GetFocusedTextBox() or input.KeyCode ~= toggleKey then return end
			windowFuncs:Toggle()
		end)
		local closeCallback = function()
			maximize:Destroy()
			for i,v in cons do
				if v and v.Connected then
					v:Disconnect()
				end
			end;
			(typeof(options.CloseCallback) == "function" and options.CloseCallback or getCallback(options))()
		end
		maximize.DragButton.MouseButton1Click:Connect(function()
			windowFuncs:Show()
		end)
		page:AddButton({Text = "Close UI", Callback = function()
			lib.Notifications:ChooseNotification({Title = "Are you sure?", Text = "Are you sure that you want to close\n"..window.HolderFrame.Title.Text.."?", Callback = function(b)
				if b then
					windowFuncs:Close()
					closeCallback()
				end
			end})
		end})
		if configsEnabled then
			page:AddSeparator()
			local currentConfig = ""
			page:AddTextBox({Text = "Config name", NeedEnter = false, Callback = function(text)
				currentConfig = text
			end, IgnoreConfigs = true})
			local suffix = "-FireLib.json"
			page:AddButton({Text = "Save", Callback = function()
				writefile(currentConfig..suffix, game.HttpService:JSONEncode(configStructure))
			end})
			page:AddButton({Text = "Load", Callback = function()
				local got = readfile(currentConfig..suffix)
				if got then
					got = game.HttpService:JSONDecode(got)
				end
				if not got then return end
				configEvent:Fire(got)
			end})
		end

		return windowFuncs
	end,
}

lib.CreateWindow = lib.MakeWindow
lib.AddWindow = lib.MakeWindow
lib.Notifications.Notify = lib.Notifications.Notification
lib.Notifications.SelectNotification = lib.Notifications.ChooseNotification
lib.Notifications.SelectionNotification = lib.Notifications.ChooseNotification

getGlobalTable()._FIRELIB = lib

return lib
